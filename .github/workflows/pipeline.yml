name: CI e CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: impactahumbertofilho/api-escolar

jobs:
  # ===========================================================================
  # JOB: build
  # ===========================================================================
  # Responsável por construir a imagem Docker e fazer push para o GHCR.
  # Para PRs: faz build local sem fazer push
  # Para main: faz build e push da imagem para o registry
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Permissão para ler o código do repositório
      packages: write     # Permissão para escrever imagens no GHCR
    outputs:
      image: ${{ steps.img.outputs.IMAGE }}  # Exporta a referência da imagem (com digest) para outros jobs
    steps:
      # Faz checkout do código do repositório para a máquina de CI
      - name: Checkout
        uses: actions/checkout@v4

      # Configura QEMU para suportar múltiplas arquiteturas (ex: ARM64)
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      # Configura o Docker Buildx para builds avançadas com cache distribuído
      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      # Autentica no GHCR (GitHub Container Registry) usando o token do GitHub
      - name: Login no GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Gera tags de metadados baseada no SHA do commit (ex: sha-abc1234)
      # Não usa a tag "latest" pois ela será promovida após testes bem-sucedidos
      - name: Docker metadata (gera tag sha, sem latest)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha

      # Para Pull Requests: faz build local da imagem sem fazer push ao registry
      # Útil para validar que o Dockerfile está correto antes de fazer merge
      - name: Build (PR) sem push, com load
        if: github.event_name == 'pull_request'
        id: build_pr
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          load: true
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # Para push na branch main: faz build e push da imagem para o GHCR
      # A imagem fica disponível no registry para os próximos jobs
      - name: Build e Push (main)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        id: build_main
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # Exporta a referência imutável da imagem (com digest SHA256)
      # Usa o digest para garantir que sempre a mesma versão será usada nos testes e deploy
      # Para PRs: usa a tag local (que foi carregada com load: true)
      # Para main: usa a tag com digest do push para garantir imutabilidade
      - name: Exporta referência da imagem
        id: img
        run: |
          if [ "${{ github.event_name }}" == "push" ] && [ -n "${{ steps.build_main.outputs.digest }}" ]; then
            # Push na main: usa digest (referência imutável do registry)
            echo "IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build_main.outputs.digest }}" >> $GITHUB_OUTPUT
          else
            # PR: usa tag local (imagem carregada localmente)
            SHA_TAG=$(echo "${{ steps.meta.outputs.tags }}" | tr ' ' '\n' | head -n1)
            echo "IMAGE=$SHA_TAG" >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # JOB: test
  # ===========================================================================
  # Executa testes automatizados dentro da imagem Docker construída
  # Depende do job "build" ter sido concluído com sucesso
  # Valida que a aplicação está funcionando corretamente antes do deploy
  test:
    runs-on: ubuntu-latest
    needs: build  # Aguarda o job "build" terminar antes de iniciar
    permissions:
      contents: read
      packages: read
    steps:
      # Para PRs: faz checkout para ter acesso ao código local (necessário para a imagem carregada localmente)
      - name: Checkout (necessário para PRs)
        if: github.event_name == 'pull_request'
        uses: actions/checkout@v4

      # Faz login no GHCR apenas quando a imagem está no registry remoto (push na main)
      # Para PRs, a imagem já está localmente carregada
      - name: Login no GHCR (quando imagem está remota)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Executa os testes da aplicação dentro da imagem Docker
      # Para PRs: usa a imagem local carregada pelo job build
      # Para main: usa a referência imutável (com digest) do registry
      # O container é removido automaticamente após a execução (--rm)
      - name: Rodar testes no container (referência imutável)
        run: |
          IMAGE="${{ needs.build.outputs.image }}"
          docker run --rm "$IMAGE" python -m unittest discover -v
          # ou: docker run --rm "$IMAGE" python -m unittest test_app -v

  # ===========================================================================
  # JOB: promote
  # ===========================================================================
  # Promove a imagem testada para a tag "latest" após testes bem-sucedidos
  # Utiliza imagetools para criar um alias sem rebuild, apenas reetiquetando
  # Só executa para push na branch main (não para PRs)
  promote:
    runs-on: ubuntu-latest
    needs: [build, test]  # Aguarda build E test para garantir qualidade
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      # Configura o Docker Buildx para usar a ferramenta de manipulação de imagens
      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      # Autentica no GHCR para poder criar novas tags
      - name: Login no GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Cria uma nova tag "latest" apontando para a mesma imagem já construída
      # Isso evita rebuild da imagem, apenas reetiqueta a imagem existente
      # Muito mais rápido que fazer rebuild completo da imagem
      - name: Promote para :latest (sem rebuild)
        run: |
          SRC="${{ needs.build.outputs.image }}"
          DEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          docker buildx imagetools create --tag "$DEST" "$SRC"

  # ===========================================================================
  # JOB: deploy-azure-aca
  # ===========================================================================
  # Faz deploy da imagem aprovada e testada para o Azure Container Apps
  # Utiliza autenticação OIDC (mais seguro que usar credentials diretas)
  # Atualiza a aplicação em produção com a nova imagem
  # Só executa para push na branch main (não para PRs)
  deploy-azure-aca:
    runs-on: ubuntu-latest
    needs: [promote, build]  # Aguarda promote e build para ter a imagem :latest disponível
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      id-token: write     # Permissão para usar OIDC (autenticação sem secrets)
      contents: read
      packages: read
    steps:
      # Faz autenticação no Azure usando OIDC (Federated Identity)
      # Não usa username/password, é mais seguro e moderno
      # Precisa das variáveis de ambiente configuradas nos secrets do GitHub
      - name: Login Azure (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Atualiza a aplicação Azure Container Apps com a nova imagem
      # Usa o Azure CLI para fazer a atualização direto no resource
      # Define variável de ambiente GIT_SHA para rastrear qual commit está em produção
      # Configura limites de replicas (mín 0, máx 1) para economia de custos
      - name: Deploy da imagem aprovada (por digest)
        uses: azure/cli@v2
        with:
          inlineScript: |
            IMAGE="${{ needs.build.outputs.image }}"  # ex: ghcr.io/...@sha256:...
            az containerapp update \
              -g "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              -n "${{ secrets.AZURE_CONTAINERAPP_NAME }}" \
              --image "$IMAGE" \
              --set-env-vars GIT_SHA="${{ github.sha }}" \
              --max-replicas 1 --min-replicas 0
